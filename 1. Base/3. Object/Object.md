# Объекты
В JavaScript методы объектов могут быть записаны разными способами. Вот несколько популярных синтаксисов:
1. Метод в объекте с использованием синтаксиса `func() {}` (старый стиль): Это традиционный способ объявления метода в объекте.
```js
const obj = {
  func: function() {
    console.log("Метод с использованием function");
  }
};
obj.func(); // вызовет метод
```

2. Метод с использованием синтаксиса сокращенной записи (ES6): В ES6 можно опустить ключевое слово function и просто записать метод как `func() {}`.
```js
const obj = {
  func() {
    console.log("Метод с сокращенной записью");
  }
};
obj.func(); // вызовет метод
```

3. Метод с использованием стрелочных функций: Стрелочные функции не создают собственное значение `this`, а унаследуют его от окружающего контекста. Это может быть полезно в некоторых случаях, но не всегда подходит для методов объектов, потому что они могут потерять доступ к самому объекту через `this`.
```js
const obj = {
  func: () => {
    console.log("Метод с использованием стрелочной функции");
  }
};
obj.func(); // вызовет метод
```

Однако важно понимать, что при использовании стрелочной функции `this` будет указывать не на сам объект, а на окружение, в котором эта функция была определена.

Резюме:
- `func: function() {}` — старый стиль.
- `func() {}` — современный стиль (сокращённая запись).
- `func: () => {}` — стрелочные функции, но с особенностями работы с `this`.

Обычно для методов объектов рекомендуется использовать второй вариант (сокращённую запись) — это компактно и легко читаемо.

В JavaScript методы объектов всегда создаются с использованием function expression, потому что объект сам по себе является структурой данных, и методы присваиваются в качестве свойств объекта.

# Поверхностное и глубокое копирование 
JavaScript включает функцию `structuredClone()`, которая позволяет выполнять глубокое копирование сложных структур данных.

```js
const obj1 = {
  name: 'Alice',
  address: {
    city: 'New York',
    country: 'USA'
  }
};

const obj2 = { ...obj1 }; // или Object.assign({}, obj1)

obj2.name = 'Bob';
obj2.address.city = 'Los Angeles';

console.log(obj1.name);  // Alice
console.log(obj1.address.city);  // Los Angeles (изменилось, так как это ссылка на тот же объект)
console.log(obj2.name);  // Bob
console.log(obj2.address.city);  // Los Angeles
```

Проблема поверхностного копирования - разные массивы ссылаются на одни и те же объекты в памяти

## Как получить глубокую копию

В JavaScript есть функция `structuredClone()` для глубокого копирования массивов или объектов.
```js
const deep = structuredClone(itemsInCart)
console.log(itemsInCart[1] === deep[1])
// false
```

Ещё один способ глубокого копирования звучит достаточно глупо — нужно сериализовать копируемый объект в JSON и тут же распарсить его. В результате появится полная копия объекта:
```js
const deep = JSON.parse(JSON.stringify(itemsInCart))
console.log(itemsInCart[1] === deep[1])
// false
```
