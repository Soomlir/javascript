# Функции

## Function Declaration
```js
function getName() {
  // тело функции
}
```
- Функция, объявленная с использованием ключевого слова `function`, доступна для вызова до объявления.
- Функции могут быть `локальными` (если определены внутри другой функции) или `глобальными` (если находятся на верхнем уровне).
- Например, если функция определена внутри другого блока, она будет доступна только в этом блоке.
- Если в теле функции нет явного оператора `return`, она возвращает `undefined` по умолчанию.
- Функции в JavaScript — это объекты, поэтому их можно передавать в другие функции как аргументы, возвращать из других функций или присваивать переменным.

## Function Expression
1. Анонимная функция (переменная)
```js
const func = function () { }
```
- В этом случае создается анонимная функция, которая не имеет имени.
- Функция присваивается переменной func.

```js
const func = function () {
  // Невозможно обратиться к самой функции через имя
  console.log("Hello from the anonymous function");
};

func();  // Работает, вызовем функцию через переменную
```

2. Именованная функция (Function Expression)
```js
const func = function func2() { }
```
- В этом случае функция имеет имя (в данном случае `func2`).
- Функция также присваивается переменной func, но имя `func2` доступно внутри самой функции.
- Имя функции в этом случае не будет доступно за пределами функции, так как это `Function Expression`, и оно не становится свойством переменной `func`.
- Это может быть полезно, например, для рекурсии, когда функция вызывает саму себя по имени.
```js
const func = function func2() {
  console.log("Hello from the named function");
};

func();  // Работает, вызовем функцию через переменную

// Ошибка: нельзя вызвать функцию через ее имя из внешней области видимости
// func2();  // Error: func2 is not defined
```

## Arrow Functions
Arrow Functions - сокращённый синтаксис для объявления функций.
```js
// Arrow Function
const add = (a, b) => a + b;
```
- Не имеют собственного контекста this, наследуют окружающий контекст
- Отсутствие arguments. Если вам нужно использовать arguments в стрелочной функции, можно использовать rest-оператор
- Нет new (Нельзя использовать как конструктор)

## this
Контекст — это то, на что указывает ключевое слово `this` в конкретный момент выполнения кода.

1. Function Declaration (Обычные функции)
2. Function Expression (Функции-выражения)
Контекст this в обычных функциях: 
- В глобальном контексте (не в объекте или классе): в строгом режиме (`'use strict'`) `this` будет `undefined`. В обычном режиме `this` будет указывать на глобальный объект, который в браузере — это `window`.
```js
function regularFunction() {
  console.log(this);  // в обычном режиме: window (глобальный объект)
}
regularFunction();
```

- Когда функция вызвана как метод объекта, this будет указывать на этот объект:
```js
const obj = {
  name: 'Alice',
  greet: function() {
    console.log(this.name);  // this будет указывать на obj
  }
};

obj.greet();  // Output: Alice
```

3. Arrow Functions (Стрелочные функции)
`this` в стрелочных функциях: Важнейшая особенность стрелочных функций — это то, что они не имеют своего this. Вместо этого, this в стрелочной функции будет наследоваться от окружающего контекста, в котором эта функция была определена.

Для стрелочных функций this будет указывать на окружающий контекст, а не на объект, через который была вызвана функция:
```js
const person = {
  name: 'Alice',
  greet: () => {
    console.log(this.name);  // `this` не указывает на объект person, будет undefined
  }
};

person.greet();  // Выведет: undefined (если в глобальном контексте)
```

Стрелочная функция берет this оттуда, где она была объявлена, а не оттуда, где она была вызвана.
```js
function regularFunction() {
    console.log('regularFunction this:', this); // {name: 'test'}
    
    const arrowInside = () => console.log('arrowInside this:', this);
    arrowInside(); // {name: 'test'} - взяла this из regularFunction
}

regularFunction.call({name: 'test'});
```

Используйте стрелочные функции когда:
- Нужно сохранить контекст родительской функции
- Для колбэков, где не нужно менять this
- Для коротких анонимных функций

Не используйте стрелочные функции когда:
- Нужны методы объекта (используйте обычные функции)
- Нужно динамически изменять контекст вызова
- Для функций-конструкторов (стрелочные нельзя использовать с new)

## Что такое apply, call и bind?
Эти методы позволяют явным образом указать, какой объект должен быть привязан к this в функции. Они позволяют изменять контекст вызова функции, независимо от того, как эта функция была вызвана (например, как метод объекта или как обычная функция).
1. `call`
Метод call вызывает функцию с заданным значением this и переданными аргументами, которые передаются по отдельности.
```js
function greet() {
  console.log(`Hello, ${this.name}`);
}

const person = { name: 'Alice' };

greet.call(person);  // Выведет: "Hello, Alice"
```
В данном примере this в функции greet будет ссылаться на объект person, благодаря методу call.

2. `apply`
Метод apply аналогичен call, но принимает аргументы в виде массива (или массива аргументов), а не через запятую.
```js
function greet(greeting) {
  console.log(`${greeting}, ${this.name}`);
}

const person = { name: 'Bob' };

greet.apply(person, ['Hello']);  // Выведет: "Hello, Bob"
```
Здесь this снова будет ссылаться на объект person, и apply передает аргументы функции как массив.

3. `bind`
Метод bind не вызывает функцию немедленно, а возвращает новую функцию, привязанную к определенному контексту. Вызываемая функция будет использовать заданный контекст this при её вызове.
```js
function greet() {
  console.log(`Hello, ${this.name}`);
}

const person = { name: 'Charlie' };

const boundGreet = greet.bind(person);
boundGreet();  // Выведет: "Hello, Charlie"
```
Здесь bind создает новую функцию `boundGreet`, которая всегда будет использовать this, ссылающийся на объект person, когда её вызовут.

# Лексическое окружение
Лексическое окружение - это переменные и функции доступные функции.
Это окружение зависит от места, где функция была объявлена, а не от того, где она была вызвана.

## Что входит в лексическое окружение?
Лексическое окружение включает:
1. Переменные, которые доступны в текущем контексте.
2. Функции, которые определены в текущем контексте.
3. Контекст (например, значение this), который также привязан к этому окружению, в случае обычных функций.
