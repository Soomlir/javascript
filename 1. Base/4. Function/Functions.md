# Функции

## Function Declaration
```js
function getName() {
  // тело функции
}
```
1. Объявление функции:
- Функция, объявленная с использованием ключевого слова `function`, доступна для вызова до ее фактической строки в коде благодаря механизму `hoisting (подъем)`.
```js
console.log(getName()); // Работает, даже если вызов до определения функции
function getName() {
  return 'John';
}
```
Это связано с тем, что JavaScript "поднимает" (hoists) объявление функции в верхнюю часть области видимости (но не её тело).

2. Сильная привязка к области видимости:
- Функции могут быть `локальными` (если определены внутри другой функции) или `глобальными` (если находятся на верхнем уровне).
- Например, если функция определена внутри другого блока, она будет доступна только в этом блоке.

3. Аргументы функции:
- Аргументы можно передавать в функцию через скобки ().
- Внутри функции также доступен объект `arguments`, который представляет собой массивоподобный объект, содержащий все переданные аргументы (для обычных функций).
Пример с использованием arguments:
```js
function sum() {
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}

console.log(sum(1, 2, 3)); // 6
```
4. Значение this:
- В обычной функции контекст `this` зависит от того, как она была вызвана. Если функция вызвана в глобальной области видимости (не как метод объекта), то `this` будет ссылаться на глобальный объект (в браузере это `window`, в строгом режиме — `undefined`).
```js
function showThis() {
  console.log(this); // в глобальном контексте это будет window (в браузере)
}
showThis();
```
5. Return:
- Если в теле функции нет явного оператора `return`, она возвращает `undefined` по умолчанию.
- Функции могут возвращать значения, которые затем могут быть использованы.

6. Функции как объекты:
- Функции в JavaScript — это объекты, поэтому их можно передавать в другие функции как аргументы, возвращать из других функций или присваивать переменным.


## Function Expression
1. Анонимная функция (переменная)
```js
const func = function () { }
```
- В этом случае создается анонимная функция, которая не имеет имени.
- Функция присваивается переменной func.

```js
const func = function () {
  // Невозможно обратиться к самой функции через имя
  console.log("Hello from the anonymous function");
};

func();  // Работает, вызовем функцию через переменную
```

2. Именованная функция (Function Expression)
```js
const func = function func2() { }
```
- В этом случае функция имеет имя (в данном случае func2).
- Функция также присваивается переменной func, но имя func2 доступно внутри самой функции.
- Имя функции в этом случае не будет доступно за пределами функции, так как это Function Expression, и оно не становится свойством переменной func.
- Это может быть полезно, например, для рекурсии, когда функция вызывает саму себя по имени.
```js
const func = function func2() {
  console.log("Hello from the named function");
};

func();  // Работает, вызовем функцию через переменную

// Ошибка: нельзя вызвать функцию через ее имя из внешней области видимости
// func2();  // Error: func is not defined
```

## Arrow Functions
Arrow Functions - сокращённый синтаксис для объявления функций.
```js
// Обычная функция
function add(a, b) {
  return a + b;
}

// Arrow Function
const add = (a, b) => a + b;
```
- Не имеют собственного контекста this, наследуют окружающий контекст
- Отсутствие arguments
Если вам нужно использовать arguments в стрелочной функции, можно использовать rest-оператор
- Нет new (Нельзя использовать как конструктор)
```js
const MyClass = () => {};
const obj = new MyClass();  // Ошибка: MyClass is not a constructor
```

У них нет собственного контекста this.
стрелочные функции всегда заимствуют this из внешнего кода.
```js
const arrowFunction = () => {
  console.log(this);  // `this` ссылается на окружающий контекст (глобальный объект или undefined)
};

arrowFunction();  // В нестрогом режиме выведет `window`, в строгом — `undefined`
```

```js
const obj = {
  name: 'MyObject',
  arrowFunction: () => {
    console.log(this.name);  // `this` ссылается на глобальный объект (window или undefined)
  }
};

obj.arrowFunction();  // Выведет: undefined (потому что `this` ссылается на глобальный объект)
```
Для стрелочных функций:
- Они не имеют собственного контекста this и заимствуют его из внешнего контекста.
- В глобальном контексте this будет window (нестрогий режим) или undefined (строгий режим).



## Как передаются аргументы:
1. Простые типы (передача по значению):
- Когда мы передаем примитивные значения (например, числа, строки, булевы значения), эти значения передаются по значению.
- Это означает, что в функцию передается копия значения, и изменение параметра внутри функции не влияет на оригинальное значение.
```js
function modifyValue(num) {
  num = num + 10;
  console.log(num); // 20
}

let x = 10;
modifyValue(x);
console.log(x); // 10 (оригинальное значение x не изменилось)
```

2. Объекты и массивы (передача по ссылке):
- Когда мы передаем объекты или массивы, они передаются по ссылке. Это означает, что внутри функции параметр будет указывать на тот же объект/массив, что и переданный аргумент. Если внутри функции мы изменим содержимое объекта или массива, эти изменения отразятся на оригинале.

Пример с объектом:
```js
function modifyObject(obj) {
  obj.name = "Igor";
}

let person = { name: "John" };
modifyObject(person);
console.log(person.name); // Igor (объект был изменен)
```
Пример с массивом:
```js
function modifyArray(arr) {
  arr.push(100);
}

let numbers = [1, 2, 3];
modifyArray(numbers);
console.log(numbers); // [1, 2, 3, 100] (массив был изменен)
```

## Параметры
1. Параметры без значений по умолчанию:
Когда в функции объявлены параметры без значений по умолчанию, если вы не передадите все аргументы при вызове функции, то недостающие параметры будут иметь значение `undefined`.
```js
function getName(a, b, c, d) {
  console.log(a, b, c, d);
}

getName(1, 2, 3);  // 1 2 3 undefined
```

2. Параметры со значениями по умолчанию:
Параметры с значениями по умолчанию обычно ставят в конец списка параметров, чтобы избежать путаницы с передачей аргументов.
```js
function getName(a, b, c = 5, d = 10) {
  console.log(a, b, c, d);
}

getName(1, 2);  // 1 2 5 10
```

3. Использование arguments:
В функции можно использовать объект arguments, который является массивоподобным объектом, содержащим все переданные аргументы, независимо от того, сколько их было передано:
```js
function getName(a, b) {
  console.log(arguments);  // { 0: 1, 1: 2 }
}

getName(1, 2);
```
`arguments` позволяет обращаться ко всем переданным аргументам, даже если их меньше, чем параметров в функции.

### Резюме:
- Нет ошибки, если вы не передали все аргументы, но недостающие параметры будут иметь значение undefined, если не указано значение по умолчанию.
- Параметры по умолчанию можно ставить в конец списка параметров, чтобы избежать путаницы.
- Для работы с аргументами, которые не передаются, можно использовать объект arguments или явно задавать значения по умолчанию.


## this
Контекст — это то, к чему относится или на что указывает ключевое слово `this` в конкретный момент выполнения кода.

1. Function Declaration (Обычные функции)
Контекст this в обычных функциях: 
- В глобальном контексте (не в объекте или классе): в строгом режиме (`'use strict'`) `this` будет `undefined`. В обычном режиме `this` будет указывать на глобальный объект, который в браузере — это `window`.
```js
function regularFunction() {
  console.log(this);  // в обычном режиме: window (глобальный объект)
}
regularFunction();
```

- Когда функция вызвана как метод объекта, this будет указывать на этот объект:
```js
const obj = {
  name: 'Alice',
  greet: function() {
    console.log(this.name);  // this будет указывать на obj
  }
};

obj.greet();  // Output: Alice
```

- Когда функция вызвана через `call`, `apply` или `bind`, this можно явно установить на любой объект:
```js
function greet() {
  console.log(this.name);
}

const person = { name: 'Bob' };
greet.call(person);  // Output: Bob
```

2. Function Expression (Функции-выражения)
Function Expression может использовать new, но только в случае, если это обычная (не стрелочная) функция, которая является конструкцией для создания объектов.

Контекст this в функциях-выражениях:
- Если функция-выражение вызвана в глобальном контексте, то значение `this` в нестрогом режиме будет указывать на глобальный объект (в браузере — на `window`), а в строгом режиме (`'use strict'`) будет `undefined`.
```js
const greet = function() {
  console.log(this);  // В нестрогом режиме: window (глобальный объект)
};

greet();
```

- Если функция-выражение вызывается как метод объекта, `this` будет указывать на этот объект:
```js
const obj = {
  name: 'Charlie',
  greet: function() {
    console.log(this.name);  // this будет указывать на obj
  }
};

obj.greet();  // Output: Charlie
```

- При вызове через `call`, `apply`, или `bind` значение `this` можно задать вручную:
```js
const greet = function() {
  console.log(this.name);
};

const person = { name: 'Dave' };
greet.call(person);  // Output: Dave
```

## Что такое apply, call и bind?
Эти методы позволяют явным образом указать, какой объект должен быть привязан к this в функции. Они позволяют изменять контекст вызова функции, независимо от того, как эта функция была вызвана (например, как метод объекта или как обычная функция).
1. `call`
Метод call вызывает функцию с заданным значением this и переданными аргументами, которые передаются по отдельности.
```js
function greet() {
  console.log(`Hello, ${this.name}`);
}

const person = { name: 'Alice' };

greet.call(person);  // Выведет: "Hello, Alice"
```
В данном примере this в функции greet будет ссылаться на объект person, благодаря методу call.

2. `apply`
Метод apply аналогичен call, но принимает аргументы в виде массива (или массива аргументов), а не через запятую.
```js
function greet(greeting) {
  console.log(`${greeting}, ${this.name}`);
}

const person = { name: 'Bob' };

greet.apply(person, ['Hello']);  // Выведет: "Hello, Bob"
```
Здесь this снова будет ссылаться на объект person, и apply передает аргументы функции как массив.

3. `bind`
Метод bind не вызывает функцию немедленно, а возвращает новую функцию, привязанную к определенному контексту. Вызываемая функция будет использовать заданный контекст this при её вызове.
```js
function greet() {
  console.log(`Hello, ${this.name}`);
}

const person = { name: 'Charlie' };

const boundGreet = greet.bind(person);
boundGreet();  // Выведет: "Hello, Charlie"
```
Здесь bind создает новую функцию boundGreet, которая всегда будет использовать this, ссылающийся на объект person, когда её вызовут.

### Резюме:
- В Function Declaration и Function Expression можно изменять контекст this с помощью методов apply, call и bind.
- Стрелочные функции не позволяют изменять this с помощью этих методов, так как this в них наследуется от внешнего контекста.



3. Arrow Functions (Стрелочные функции)
Стрелочные функции (Arrow Functions) в JavaScript — это особый тип функций, введённый в ES6. Они имеют несколько ключевых отличий и особенностей по сравнению с Function Declaration и Function Expression.

Основные особенности стрелочных функций:
1. Синтаксис: Стрелочные функции имеют более компактный синтаксис, который убирает необходимость в использовании ключевого слова function и фигурных скобок (если тело функции состоит из одного выражения).
```js
const greet = (name) => `Hello, ${name}!`;
```

2. this в стрелочных функциях: Важнейшая особенность стрелочных функций — это то, что они не имеют своего this. Вместо этого, this в стрелочной функции будет наследоваться от окружающего контекста, в котором эта функция была определена.

Это отличается от обычных функций, где this зависит от того, как была вызвана функция (через объект или как обычная функция).

Пример:
```js
const person = {
  name: 'Alice',
  greet: function() {
    console.log(this.name);  // `this` указывает на объект person
  }
};

person.greet();  // Выведет: "Alice"
```
Для стрелочных функций this будет указывать на окружающий контекст, а не на объект, через который была вызвана функция:
```js
const person = {
  name: 'Alice',
  greet: () => {
    console.log(this.name);  // `this` не указывает на объект person
  }
};

person.greet();  // Выведет: undefined (если в глобальном контексте)
```

В стрелочных функциях this всегда ссылается на контекст, в котором эта функция была определена, а не на объект, который её вызывает.

3. Отсутствие arguments
4. Невозможность использовать с new: Стрелочные функции не могут быть использованы как конструкторы, так как они не имеют своего this и не могут быть вызваны с помощью new.

Arrow Function: Это компактная форма записи для Function Expression, где нет ключевого слова function, а используется =>. Стрелочные функции всегда являются анонимными (это значит, что стрелочная функция не имеет имени, в отличие от обычной функции, которая может быть названа при её объявлении).

Верхняя область видимости — это область видимости на глобальном уровне, которая зависит от контекста выполнения (например, браузер или Node.js). В классическом подходе с подключением файлов она относится к глобальному пространству, а в случае модульной системы каждый файл имеет свою собственную область видимости, изолированную от других.

##  Асинхронные функции (Async Functions)
- Асинхронные функции всегда возвращают промис, независимо от того, что они возвращают внутри (обычное значение или промис).
- Ключевое слово await позволяет "приостановить" выполнение функции до получения значения из промиса, что облегчает работу с асинхронным кодом.

## Immediately Invoked Function Expressions (IIFE)
Это функции, которые выполняются сразу после своего объявления. Они используются для создания замкнутых областей видимости (например, для изоляции переменных).

# Лексическое окружение
Лексическое окружение - это переменные и функции доступные функции.
Это окружение зависит от места, где функция была объявлена, а не от того, где она была вызвана.

## Что входит в лексическое окружение?
Лексическое окружение включает:
1. Переменные, которые доступны в текущем контексте.
2. Функции, которые определены в текущем контексте.
3. Контекст (например, значение this), который также привязан к этому окружению, в случае обычных функций.

# Замыкания
Замыкание (`closure`) в JavaScript — это функция, которая «запоминает» своё лексическое окружение, то есть доступ к переменным из внешней функции, даже после того как эта внешняя функция завершит своё выполнение.

## Что такое замыкание?
Замыкание возникает, когда функция используется внутри другой функции, и внутренняя функция сохраняет доступ к переменным внешней функции, даже если внешняя функция уже завершила своё выполнение.

## Зачем нужно замыкание?

### 1. `Инкапсуляция данных`. Замыкания позволяют создавать приватные переменные, которые доступны только внутри функции. Это полезно для скрытия реализации и защиты данных.

### 2. `Функции с состоянием`. Замыкания позволяют создавать функции, которые могут "помнить" своё состояние между вызовами, что полезно для счетчиков, обработчиков событий и других сценариев.

### 3. `Функции высшего порядка`. Замыкания часто используются для создания функций, которые возвращают другие функции с состоянием.

## Как использовать замыкания?

Пример замыкания:
```js
function outer() {
    let counter = 0; // Переменная внешней функции
    return function inner() { // Внутренняя функция
        counter++;
        console.log(counter);
    }
}

const increment = outer(); // Внешняя функция вернула внутреннюю
increment(); // 1
increment(); // 2
increment(); // 3
```

В этом примере:
- Внешняя функция outer() создаёт переменную counter.
- Внутренняя функция inner() использует эту переменную.
- Замыкание позволяет внутренней функции inner() "помнить" значение counter, даже после того как выполнение внешней функции завершилось.

## Пример использования замыкания для инкапсуляции:
```js
function createCounter() {
    let count = 0; // Приватная переменная
    return {
        increment: function() {
            count++;
            console.log(count);
        },
        decrement: function() {
            count--;
            console.log(count);
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();
counter.increment(); // 1
counter.increment(); // 2
console.log(counter.getCount()); // 2
counter.decrement(); // 1
```

Здесь:
- Переменная count скрыта от внешнего кода.
- Мы получаем доступ к ней только через публичные методы increment(), decrement() и getCount().
- Замыкание позволяет создать приватное состояние, которое недоступно из внешнего кода, но доступно через методы объекта.

## Итого:
Замыкания — это мощный инструмент в JavaScript, который используется для:
- Инкапсуляции состояния и данных.
- Создания функций с памятью.
- Решения множества задач, таких как обработка событий, отложенные вычисления и т.д.
